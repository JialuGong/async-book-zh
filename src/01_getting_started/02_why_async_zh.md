# 为什么使用异步？

我们都钟意于Rust所赋予的编写快速、安全代码的能力。但是异步编程是如何适应这个愿景的呢？异步式编程，或者简称为async,是一种被越来越多语言所支持的 _并发编程模型_（_concurrent programming 
model_）。通过`async/await`语法，异步编程能够让你使用少数的系统线程就能运行大量的同步任务，并且代码风格与传统的同步编程风格相似。

## Async vs 其它并发模型
目前，并发编程不如常规的顺序编程成熟和“标准化”。因此，并发的表示会根据语言支持的并发编程模型而有​​所不同。接下来我们会对最流行的并发模型进行简要概述，这或许可以帮助你了解异步编程是如何适应更广泛的并发编程领域的。
- **系统线程（OS threads）**不需要对编程模型进行任何更改，这使得表达并发非常容易。然而在这种模式下，线程间的同步是非常困难的，性能的开销也很大。线程池可以降低其中一些开销，但不足以支持大量 IO 密集型工作负载。
- **事件驱动型编程**与 _回调_相结合，能够得到非常好的性能。但是该模型会导致冗余的、非线性的控制流。数据流和错误传播会变得非常难以跟踪。
- **协程(Coroutines)**，与线程十分相似，也不用改变编程模型，这让它易于使用。同时它也和async非常相似，能够支持大量同步任务。然而，协程抽象出了底层细节，这些底层细节对于系统编程和自定义的运行时非常重要。
- **actor模型**将所有的并行计算划分为名为actor的单元，这些单元通过不可靠的消息传递进行通信，就像是分布式系统一样。actor模型可以有效地被实现，但是却存在需要实际问题没有得到解决，例如控制流和重试逻辑。

总而言之， 异步编程能够使类似rust这样的底层语言实现高性能的同时，也提供了大部分人线程和协程所拥有的人体工程学的好处。

## Rust 与其他语言中的异步
虽然大部分语言都实现了异步编程，但是实现的细节各有不同。Rust关于异步的实现与大多数语言的不同之处主要体现几点：
- **Future在Rust中是惰性的**，只有当轮询时，future才会取得进展。释放(Drop)掉一个future会阻止它进一步进展。
- **异步在Rust中是零成本的**，这意味着开销仅被用在异步所完成的事上。具体来说，你可以在没有堆分配和动态调度的情况下使用异步，这对提高性能十分有用！这还允许您在受限环境中使用异步，例如嵌入式系统。
- **Rust不提供内置运行时**。相反，运行时是由社区维护的crates提供。
- **Rust中提供了单线程和多线程** 运行时，它们各有优缺点。

## Rust 中的异步与线程
Rust中异步的主要替代方法是使用操作系统线程，要么直接通过 [`std::thread`](https://doc.rust-lang.org/std/thread/) 或间接通过线程池。无论是在实现方面还是，还是任何暴露出的公共接口方面（如果您正在构建库），从线程迁移到异步常需要大量的重构工作，反之亦然。因此，尽早选择适合你需求的模型可以节省大量开发时间。

**OS 线程** 适用于少量任务，因为线程具有 CPU 和内存开销。线程的产生和线程间的切换非常昂贵，因为即使是空闲线程也会消耗系统资源。线程池库可以帮助减轻其中一些成本，但不是全部。但是，线程允许您重用现有的同步代码，而无需进行太大的代码更改——不需要特定的编程模型。在某些操作系统中，您还可以更改线程的优先级，这对于驱动程序和其他延迟敏感的应用程序十分有用。

**异步**显著减少了CPU和内存的开销，尤其是对于具有IO密集型任务，例如服器和数据库。在其他条件相同的情况下，您可以拥有比 OS 线程更多数量级的任务，因为异步运行时使用少量（昂贵）的线程来处理大量（廉价）的任务。但是，由于异步函数生成的状态机以及每个可执行文件捆绑了一个异步运行时，异步 Rust 会导致生成的二进制文件更大。

最后一点，异步编程和线程之前并非孰优孰劣，而是各有千秋。如果出于性能原因不需要异步，线程往往是更简单的选择。

### 例子：并发下载
在这个例子中，我们的目标是同时下载两个网页。在典型的线程应用程序中，我们需要生成线程实现并发：

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites}}
```
但是，下载网页是一项小任务。为这么少量的工作创建一个线程是相当浪费的。对于更大的应用程序，它很容易成为瓶颈。在 async Rust 中，我们可以在没有额外线程的情况下同时运行这些任务：

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites_async}}
```
在代码中，我们没有创建额外的线程。此外，所有函数调用都是静态分派的，并且有堆分配！但是，我们首先需要编写异步代码，不过不用担心，本书将帮助您实现这一点。

## Rust中的自定义并发模型
最后一点，Rust 不会强迫您在线程和异步之间进行选择。你可以在同一个应用程序中使用这两种模型，这在你同时拥有线程和异步依赖项时会很有用。事实上，你甚至可以完全使用不同的并发模型，比如事件驱动模型，只要找到实现它的库即可
